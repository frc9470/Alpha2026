// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package com.team9470;

import choreo.auto.AutoChooser;
import com.team9470.commands.Autos;
import com.team9470.commands.WheelRadiusCharacterization;
import com.team9470.telemetry.TelemetryManager;
import com.team9470.telemetry.structs.YShotSnapshot;
import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.Commands;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.team9470.subsystems.swerve.Swerve;
import com.team9470.subsystems.Superstructure;
import com.team9470.subsystems.shooter.ShooterConstants;
import com.ctre.phoenix6.swerve.SwerveModule;
import com.ctre.phoenix6.swerve.SwerveRequest;

import edu.wpi.first.wpilibj2.command.button.CommandXboxController;
import com.team9470.Constants.OperatorConstants;
import com.team9470.subsystems.vision.Vision;
import static edu.wpi.first.units.Units.*;

public class RobotContainer {

  private final double MaxSpeed = TunerConstants.kSpeedAt12Volts.in(MetersPerSecond);
  private final double MaxAngularRate = Math.toRadians(TunerConstants.maxAngularVelocity);

  // Swerve requests
  private final SwerveRequest.FieldCentric drive = new SwerveRequest.FieldCentric()
      .withDeadband(MaxSpeed * 0.1).withRotationalDeadband(MaxAngularRate * 0.1)
      .withDriveRequestType(SwerveModule.DriveRequestType.OpenLoopVoltage);

  // Subsystems
  private final Swerve m_swerve = Swerve.getInstance();
  private final Superstructure m_superstructure = Superstructure.getInstance();
  private final Vision m_vision = Vision.getInstance();
  private final Autos m_autos = new Autos(m_swerve);
  private final AutoChooser m_autoChooser = new AutoChooser();
  private final TelemetryManager telemetry = TelemetryManager.getInstance();

  // Controllers
  private final CommandXboxController m_driverController = new CommandXboxController(
      OperatorConstants.kDriverControllerPort);

  // Debug Y-shot dashboard tuning (only used by Y button command)
  private static final String kDebugYShotRpmKey = "Debug/YShot/RPM";
  private static final String kDebugYShotHoodDegKey = "Debug/YShot/HoodAngleDeg";
  private static final double kDebugYShotDefaultRpm = 3000.0;
  private static final double kDebugYShotDefaultHoodDeg = 30.0;
  private static final double kShootTranslationDeadband = 0.10;
  private static final double kIntakeHeadingLockMinSpeedMps = 0.15;
  private static final double kIntakeHeadingLockKp = 3.5;
  private static final double kIntakeHeadingManualOverrideDeadband = 0.10;

  public RobotContainer() {
    // Connect swerve context to superstructure
    m_superstructure.setDriveContext(
        m_swerve::getPose,
        m_swerve::getChassisSpeeds);

    initDebugYShotDashboard();
    configureBindings();
    configureAutonomous();
  }

  private void initDebugYShotDashboard() {
    SmartDashboard.putNumber(kDebugYShotRpmKey, kDebugYShotDefaultRpm);
    SmartDashboard.putNumber(kDebugYShotHoodDegKey, kDebugYShotDefaultHoodDeg);
  }

  private final SwerveRequest.SwerveDriveBrake xLock = new SwerveRequest.SwerveDriveBrake();

  private double getDefaultDriveRotationRate(double vX, double vY, double rightXInput) {
    double manualRotationRate = -rightXInput * MaxAngularRate;

    // Heading lock is only active while left trigger is held.
    if (!m_driverController.leftTrigger().getAsBoolean()) {
      return manualRotationRate;
    }
    if (Math.abs(rightXInput) > kIntakeHeadingManualOverrideDeadband) {
      return manualRotationRate;
    }

    double speed = Math.hypot(vX, vY);
    if (speed < kIntakeHeadingLockMinSpeedMps) {
      return 0.0;
    }

    Rotation2d desiredHeading = new Rotation2d(vX, vY);
    double headingErrorRad = MathUtil.angleModulus(
        desiredHeading.minus(m_swerve.getPose().getRotation()).getRadians());
    return MathUtil.clamp(headingErrorRad * kIntakeHeadingLockKp, -MaxAngularRate, MaxAngularRate);
  }

  private double getShootTranslationSpeed(double rawAxisInput) {
    return -MathUtil.applyDeadband(rawAxisInput, kShootTranslationDeadband) * MaxSpeed;
  }

  private void configureBindings() {
    // ==================== TRIGGERS ====================

    // Left Trigger: Heading-lock modifier only (no intake command binding)

    // Right Trigger: Auto-Aim & Shoot/Feed
    m_driverController.rightTrigger().whileTrue(
        m_superstructure.aimAndShootCommand(
            () -> getShootTranslationSpeed(m_driverController.getLeftY()),
            () -> getShootTranslationSpeed(m_driverController.getLeftX())));

    // ==================== BUMPERS ====================

    // Left Bumper: Toggle intake deployed/retracted
    m_driverController.leftBumper().onTrue(m_superstructure.toggleIntakeCommand());

    // Right Bumper: Feed (500 RPM, max hood angle)
    m_driverController.rightBumper().whileTrue(m_superstructure.feedCommand());

    // ==================== FACE BUTTONS ====================

    // X: X-lock wheels (defensive stance)
    m_driverController.x().whileTrue(m_swerve.applyRequest(() -> xLock));

    // B: Zero swerve heading (reset field-centric forward)
    m_driverController.b().onTrue(m_swerve.runOnce(() -> m_swerve.seedFieldCentric()));

    // Start: Toggle intake to deploy-high (+10 deg) / retract
    m_driverController.start().onTrue(m_superstructure.toggleIntakeHighCommand());

    // Back: Hold to run wheel radius characterization spin test
    m_driverController.back().whileTrue(new WheelRadiusCharacterization(m_swerve));

    // A: Debug - Run hopper while held
    m_driverController.a().whileTrue(m_superstructure.getHopper().runCommand());

    // Y: Debug - Spin up shooter + set hood from dashboard + feed hopper while held
    m_driverController.y().whileTrue(
        Commands.runEnd(
            () -> {
              double requestedRpm = SmartDashboard.getNumber(kDebugYShotRpmKey, kDebugYShotDefaultRpm);
              double requestedHoodDeg = SmartDashboard.getNumber(kDebugYShotHoodDegKey, kDebugYShotDefaultHoodDeg);
              double rpm = Math.max(0.0, requestedRpm);
              double hoodDeg = requestedHoodDeg;
              double clampedHoodDeg = Math.max(
                  ShooterConstants.kMinHoodAngle.in(Degrees),
                  Math.min(ShooterConstants.kMaxHoodAngle.in(Degrees), hoodDeg));
              double targetRps = rpm / 60.0;

              m_superstructure.getShooter().setFlywheelSpeed(targetRps);
              m_superstructure.getShooter().setHoodAngle(
                  ShooterConstants.launchRadToMechanismRotations(Math.toRadians(clampedHoodDeg)));
              boolean shooterAtSetpoint = m_superstructure.getShooter().isAtSetpoint();
              m_superstructure.getIntake().setShooting(true);
              m_superstructure.getIntake().setAgitating(true);
              // Y debug should force-feed immediately instead of waiting for shooter
              // readiness.
              m_superstructure.getShooter().setFiring(true);
              m_superstructure.getHopper().setRunning(true);

              telemetry.publishYShotState(new YShotSnapshot(
                  true,
                  requestedRpm / 60.0,
                  Math.toRadians(requestedHoodDeg),
                  rpm / 60.0,
                  Math.toRadians(clampedHoodDeg),
                  shooterAtSetpoint));
            },
            () -> {
              m_superstructure.getShooter().stop();
              m_superstructure.getHopper().stop();
              m_superstructure.getIntake().setShooting(false);
              m_superstructure.getIntake().setAgitating(false);
              telemetry.publishYShotState(new YShotSnapshot(
                  false,
                  0.0,
                  0.0,
                  0.0,
                  0.0,
                  false));
            }));

    // Right Stick (press): Low-priority manual re-home for intake + hood
    m_driverController.rightStick().onTrue(m_superstructure.homeIntakeAndHoodCommand());

    // ==================== DEFAULT COMMANDS ====================
    m_swerve.setDefaultCommand(
        m_swerve.applyRequest(() -> {
          double vX = -m_driverController.getLeftY() * MaxSpeed;
          double vY = -m_driverController.getLeftX() * MaxSpeed;
          double omega = getDefaultDriveRotationRate(vX, vY, m_driverController.getRightX());
          return drive
              .withVelocityX(vX)
              .withVelocityY(vY)
              .withRotationalRate(omega);
        }));
  }

  private void configureAutonomous() {
    m_autoChooser.addRoutine("Do Nothing", m_autos::doNothing);
    m_autoChooser.addRoutine("trenchRight", m_autos::trenchRight);
    m_autoChooser.addRoutine("trenchLeft", m_autos::trenchLeft);
    m_autoChooser.addRoutine("bumpRightBlue", m_autos::bumpRightBlue);
    m_autoChooser.addRoutine("figure8", m_autos::figure8);
    m_autoChooser.select("Do Nothing");
    SmartDashboard.putData("AutoChooser", m_autoChooser);
  }

  public Command getAutonomousCommand() {
    return m_autoChooser.selectedCommandScheduler();
  }
}
